<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Liveness Check</title>
  <style>
    :root {
      --bg: #0a0e14;
      --text: #f0f2f5;
      --muted: #8b95a5;
      --green: #22c55e;
      --yellow: #eab308;
      --red: #ef4444;
      --blue: #3b82f6;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { 
      height: 100%; 
      background: var(--bg); 
      color: var(--text);
      font: 14px/1.4 system-ui, -apple-system, sans-serif;
    }
    
    .app {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    
    .card {
      width: min(420px, 100%);
      border-radius: 20px;
      overflow: hidden;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    /* Camera Stage */
    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 3/4;
      background: #000;
    }
    
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }
    
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    /* Status Pill */
    .status-pill {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 100px;
      backdrop-filter: blur(10px);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--muted);
    }
    .status-dot.ok { background: var(--green); }
    .status-dot.warn { background: var(--yellow); }
    .status-dot.bad { background: var(--red); }
    .status-text {
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Bottom HUD */
    .hud {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 60px 16px 16px;
      background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    
    .hint {
      text-align: center;
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
    }
    .hint-sub {
      font-size: 13px;
      color: var(--muted);
      margin-top: 4px;
    }
    
    /* Progress dots */
    .progress {
      display: none;
      gap: 8px;
    }
    .progress.show { display: flex; }
    .progress .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(255,255,255,0.25);
      transition: all 0.2s;
    }
    .progress .dot.done { background: var(--green); }
    .progress .dot.active { background: var(--yellow); animation: pulse 0.8s infinite; }
    @keyframes pulse { 50% { transform: scale(1.3); } }
    
    /* Button */
    .btn {
      appearance: none;
      border: none;
      padding: 14px 32px;
      border-radius: 14px;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s;
      background: var(--blue);
      color: white;
    }
    .btn:hover:not(:disabled) { filter: brightness(1.1); }
    .btn:active:not(:disabled) { transform: scale(0.98); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn.secondary {
      background: rgba(255,255,255,0.1);
      color: var(--text);
    }
    
    /* Result */
    .result {
      display: none;
      padding: 20px;
      text-align: center;
    }
    .result.show { display: block; }
    .result img {
      width: 120px;
      height: 150px;
      object-fit: cover;
      border-radius: 14px;
      border: 3px solid var(--green);
      margin-bottom: 16px;
    }
    .result-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 4px;
    }
    .result-title.fail { color: var(--red); }
    .result-sub {
      font-size: 14px;
      color: var(--muted);
      margin-bottom: 20px;
    }
    
    /* Loading overlay */
    .loading {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
    }
    .loading.show { display: flex; }
    .spinner {
      width: 36px;
      height: 36px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top-color: var(--blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-text {
      font-size: 14px;
      color: var(--muted);
    }
    
    /* Error */
    .error {
      display: none;
      padding: 12px 16px;
      margin: 12px 16px;
      background: rgba(239,68,68,0.1);
      border: 1px solid rgba(239,68,68,0.3);
      border-radius: 12px;
      font-size: 13px;
      color: #fca5a5;
    }
    .error.show { display: block; }
  </style>
</head>

<body>
<div class="app">
  <div class="card">
    <!-- Camera Stage -->
    <div class="stage" id="stage">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="overlay"></canvas>
      
      <div class="status-pill">
        <div class="status-dot" id="statusDot"></div>
        <div class="status-text" id="statusText">Ready</div>
      </div>
      
      <div class="hud">
        <div class="progress" id="progress">
          <div class="dot" id="p0"></div>
          <div class="dot" id="p1"></div>
          <div class="dot" id="p2"></div>
          <div class="dot" id="p3"></div>
          <div class="dot" id="p4"></div>
        </div>
        
        <div>
          <div class="hint" id="hint">Enable camera to start</div>
          <div class="hint-sub" id="hintSub">Position your face in the oval</div>
        </div>
        
        <button class="btn" id="btnMain">Enable Camera</button>
      </div>
      
      <div class="loading" id="loading">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Loading...</div>
      </div>
    </div>
    
    <!-- Result -->
    <div class="result" id="result">
      <img id="resultImg" src="" alt="Captured">
      <div class="result-title" id="resultTitle">Verified!</div>
      <div class="result-sub" id="resultSub">Liveness confirmed</div>
      <button class="btn secondary" id="btnRetry">Try Again</button>
    </div>
    
    <div class="error" id="error"></div>
  </div>
</div>

<script type="module">
/***********************************************************************
 * CONFIG
 ***********************************************************************/
const CONFIG = {
  // Set to your backend URL, or leave as "mock" for demo mode
  API_BASE: new URLSearchParams(location.search).get("api") || "mock",
  
  // Capture settings
  TARGET_FRAMES: 5,
  CAPTURE_WINDOW_MS: 4000,
  MIN_SPACING_MS: 280,
  STABLE_FRAMES_REQUIRED: 8,
  
  // Quality
  MIN_LUMA: 50,
  MAX_LUMA: 210,
  MIN_CONTRAST: 30,
};

const IS_MOCK = CONFIG.API_BASE.toLowerCase() === "mock";

/***********************************************************************
 * DOM
 ***********************************************************************/
const $ = id => document.getElementById(id);
const video = $("video");
const overlay = $("overlay");
const ctx = overlay.getContext("2d", { alpha: true });

/***********************************************************************
 * STATE
 ***********************************************************************/
const state = {
  phase: "init", // init | ready | scanning | capturing | verifying | done
  faceLandmarker: null,
  
  // Detection
  stableFrames: 0,
  faceInOval: false,
  
  // Capture
  captured: [],
  captureStartMs: 0,
  lastCaptureMs: 0,
  sessionId: null,
  nonce: null,
};

/***********************************************************************
 * UI HELPERS
 ***********************************************************************/
function setStatus(text, type = "") {
  $("statusText").textContent = text;
  $("statusDot").className = "status-dot " + type;
}

function setHint(main, sub = "") {
  $("hint").textContent = main;
  $("hintSub").textContent = sub;
}

function setLoading(on, text = "Loading...") {
  $("loading").classList.toggle("show", on);
  $("loadingText").textContent = text;
}

function setError(msg) {
  $("error").textContent = msg;
  $("error").classList.toggle("show", !!msg);
}

function setButton(text, enabled = true) {
  $("btnMain").textContent = text;
  $("btnMain").disabled = !enabled;
}

function updateProgress() {
  const show = state.phase === "capturing";
  $("progress").classList.toggle("show", show);
  
  for (let i = 0; i < CONFIG.TARGET_FRAMES; i++) {
    const dot = $(`p${i}`);
    dot.className = "dot";
    if (i < state.captured.length) dot.classList.add("done");
    else if (i === state.captured.length && show) dot.classList.add("active");
  }
}

function showResult(success, imageData, message) {
  $("stage").style.display = "none";
  $("result").classList.add("show");
  
  $("resultImg").src = imageData || "";
  $("resultImg").style.borderColor = success ? "var(--green)" : "var(--red)";
  $("resultTitle").textContent = success ? "Verified!" : "Failed";
  $("resultTitle").classList.toggle("fail", !success);
  $("resultSub").textContent = message || (success ? "Liveness confirmed" : "Please try again");
}

function hideResult() {
  $("stage").style.display = "block";
  $("result").classList.remove("show");
}

/***********************************************************************
 * OVAL DRAWING
 ***********************************************************************/
function resizeCanvas() {
  const rect = overlay.getBoundingClientRect();
  const dpr = Math.max(1, devicePixelRatio || 1);
  overlay.width = rect.width * dpr;
  overlay.height = rect.height * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function getOval() {
  const w = overlay.getBoundingClientRect().width;
  const h = overlay.getBoundingClientRect().height;
  return {
    cx: w * 0.5,
    cy: h * 0.46,
    rx: w * 0.32,
    ry: h * 0.38
  };
}

function pointInOval(x, y, oval) {
  const dx = (x - oval.cx) / oval.rx;
  const dy = (y - oval.cy) / oval.ry;
  return dx * dx + dy * dy <= 1.0;
}

function drawOval(isGood) {
  const w = overlay.getBoundingClientRect().width;
  const h = overlay.getBoundingClientRect().height;
  const oval = getOval();
  
  ctx.clearRect(0, 0, w, h);
  
  // Dim outside
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.5)";
  ctx.fillRect(0, 0, w, h);
  ctx.globalCompositeOperation = "destination-out";
  ctx.beginPath();
  ctx.ellipse(oval.cx, oval.cy, oval.rx, oval.ry, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  
  // Ring
  ctx.save();
  ctx.lineWidth = 3;
  ctx.strokeStyle = isGood ? "rgba(34,197,94,0.9)" : "rgba(255,255,255,0.6)";
  ctx.shadowColor = isGood ? "rgba(34,197,94,0.5)" : "transparent";
  ctx.shadowBlur = isGood ? 15 : 0;
  ctx.beginPath();
  ctx.ellipse(oval.cx, oval.cy, oval.rx, oval.ry, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

/***********************************************************************
 * MEDIAPIPE
 ***********************************************************************/
async function loadMediaPipe() {
  setLoading(true, "Loading face detection...");
  
  try {
    const mod = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs");
    const vision = await mod.FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
    );
    
    state.faceLandmarker = await mod.FaceLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
        delegate: "GPU"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFaceBlendshapes: true
    });
    
    return true;
  } catch (e) {
    console.error("MediaPipe error:", e);
    setError("Failed to load face detection. Check your connection.");
    return false;
  } finally {
    setLoading(false);
  }
}

/***********************************************************************
 * CAMERA
 ***********************************************************************/
async function startCamera() {
  setLoading(true, "Starting camera...");
  setError("");
  
  try {
    // Check if getUserMedia is supported
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("Camera not supported in this browser");
    }
    
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } },
      audio: false
    });
    
    video.srcObject = stream;
    
    // Wait for video to be ready
    await new Promise((resolve, reject) => {
      video.onloadedmetadata = () => {
        console.log("Video metadata loaded:", video.videoWidth, "x", video.videoHeight);
        resolve();
      };
      video.onerror = (e) => reject(new Error("Video element error"));
      setTimeout(() => reject(new Error("Video load timeout")), 10000);
    });
    
    // Play video
    try {
      await video.play();
      console.log("Video playing");
    } catch (playErr) {
      console.warn("Autoplay blocked, trying muted:", playErr);
      video.muted = true;
      await video.play();
    }
    
    // Verify video is actually playing
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      throw new Error("Camera started but no video data");
    }
    
    console.log("Camera OK:", video.videoWidth, "x", video.videoHeight);
    return true;
    
  } catch (e) {
    console.error("Camera error:", e);
    
    // Better error messages
    let msg = "Camera error: " + e.message;
    if (e.name === "NotAllowedError" || e.name === "PermissionDeniedError") {
      msg = "Camera permission denied. Please allow camera access in your browser settings.";
    } else if (e.name === "NotFoundError" || e.name === "DevicesNotFoundError") {
      msg = "No camera found. Please connect a camera.";
    } else if (e.name === "NotReadableError" || e.name === "TrackStartError") {
      msg = "Camera is in use by another app. Close other apps using the camera.";
    } else if (e.name === "OverconstrainedError") {
      msg = "Camera constraints not supported. Trying default settings...";
      // Try again with minimal constraints
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        video.srcObject = stream;
        await new Promise(r => video.onloadedmetadata = r);
        await video.play();
        setLoading(false);
        return true;
      } catch (e2) {
        msg = "Camera failed even with default settings: " + e2.message;
      }
    }
    
    setError(msg);
    return false;
  } finally {
    setLoading(false);
  }
}

function stopCamera() {
  const stream = video.srcObject;
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    video.srcObject = null;
  }
}

/***********************************************************************
 * SERVER API
 ***********************************************************************/
async function apiStartSession() {
  if (IS_MOCK) {
    state.sessionId = "mock-" + Date.now();
    state.nonce = Math.random().toString(36).slice(2);
    return true;
  }
  
  try {
    const r = await fetch(`${CONFIG.API_BASE}/session/start`, { method: "POST" });
    if (!r.ok) throw new Error("Server error");
    const data = await r.json();
    state.sessionId = data.session_id;
    state.nonce = data.nonce;
    return true;
  } catch (e) {
    console.error("Session error:", e);
    return false;
  }
}

async function apiVerify(frames) {
  if (IS_MOCK) {
    await new Promise(r => setTimeout(r, 600));
    return {
      decision: "PASS",
      confidence: 0.94,
      spoof_score: 0.06,
      best_frame_id: frames.length - 1
    };
  }
  
  try {
    const r = await fetch(`${CONFIG.API_BASE}/verify`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        session_id: state.sessionId,
        nonce: state.nonce,
        frames,
        client_metadata: { user_agent: navigator.userAgent }
      })
    });
    if (!r.ok) throw new Error("Verification failed");
    return await r.json();
  } catch (e) {
    console.error("Verify error:", e);
    return null;
  }
}

/***********************************************************************
 * QUALITY CHECK
 ***********************************************************************/
function checkQuality(x, y, w, h) {
  const tmp = document.createElement("canvas");
  tmp.width = 64;
  tmp.height = 64;
  const tctx = tmp.getContext("2d");
  tctx.drawImage(video, x, y, w, h, 0, 0, 64, 64);
  
  const img = tctx.getImageData(0, 0, 64, 64);
  const d = img.data;
  
  let sum = 0, min = 255, max = 0;
  for (let i = 0; i < d.length; i += 4) {
    const luma = 0.299 * d[i] + 0.587 * d[i+1] + 0.114 * d[i+2];
    sum += luma;
    if (luma < min) min = luma;
    if (luma > max) max = luma;
  }
  
  const mean = sum / (d.length / 4);
  const contrast = max - min;
  
  return mean >= CONFIG.MIN_LUMA && mean <= CONFIG.MAX_LUMA && contrast >= CONFIG.MIN_CONTRAST;
}

function checkEyesOpen(blendshapes) {
  if (!blendshapes?.length) return true;
  const shapes = blendshapes[0].categories;
  const left = shapes.find(s => s.categoryName === "eyeBlinkLeft");
  const right = shapes.find(s => s.categoryName === "eyeBlinkRight");
  if (!left || !right) return true;
  return left.score < 0.5 && right.score < 0.5;
}

/***********************************************************************
 * CAPTURE FRAME
 ***********************************************************************/
function captureFrame(box) {
  const size = 224;
  const tmp = document.createElement("canvas");
  tmp.width = size;
  tmp.height = size;
  const tctx = tmp.getContext("2d");
  
  // Mirror
  tctx.translate(size, 0);
  tctx.scale(-1, 1);
  tctx.drawImage(video, box.x, box.y, box.w, box.h, 0, 0, size, size);
  
  return tmp.toDataURL("image/jpeg", 0.75);
}

/***********************************************************************
 * MAIN LOOP
 ***********************************************************************/
function loop() {
  if (state.phase !== "scanning" && state.phase !== "capturing") return;
  
  const now = performance.now();
  const vw = video.videoWidth;
  const vh = video.videoHeight;
  
  resizeCanvas();
  
  // Detect face
  const result = state.faceLandmarker.detectForVideo(video, now);
  const faces = result?.faceLandmarks;
  
  let faceBox = null;
  let faceInOval = false;
  let faceTooSmall = false;
  let faceTooBig = false;
  let faceOffCenter = false;
  
  const displayW = overlay.getBoundingClientRect().width;
  const displayH = overlay.getBoundingClientRect().height;
  const oval = getOval();
  
  if (faces?.length) {
    const lm = faces[0];
    let minX = 1, maxX = 0, minY = 1, maxY = 0;
    for (const p of lm) {
      if (p.x < minX) minX = p.x;
      if (p.x > maxX) maxX = p.x;
      if (p.y < minY) minY = p.y;
      if (p.y > maxY) maxY = p.y;
    }
    
    // Face bounds in display coordinates (mirrored)
    const faceLeft = (1 - maxX) * displayW;
    const faceRight = (1 - minX) * displayW;
    const faceTop = minY * displayH;
    const faceBottom = maxY * displayH;
    const faceCenterX = (faceLeft + faceRight) / 2;
    const faceCenterY = (faceTop + faceBottom) / 2;
    const faceW = faceRight - faceLeft;
    const faceH = faceBottom - faceTop;
    
    // Check face size relative to oval
    const ovalW = oval.rx * 2;
    const ovalH = oval.ry * 2;
    const sizeRatioW = faceW / ovalW;
    const sizeRatioH = faceH / ovalH;
    
    faceTooSmall = sizeRatioW < 0.5 || sizeRatioH < 0.5;
    faceTooBig = sizeRatioW > 1.1 || sizeRatioH > 1.1;
    
    // Check if center is in oval
    const centerInOval = pointInOval(faceCenterX, faceCenterY, oval);
    
    // Check if face corners fit in oval (with some tolerance)
    const margin = 0.15; // 15% margin
    const checkPoints = [
      { x: faceLeft + faceW * margin, y: faceTop + faceH * margin },      // top-left
      { x: faceRight - faceW * margin, y: faceTop + faceH * margin },     // top-right
      { x: faceLeft + faceW * margin, y: faceBottom - faceH * margin },   // bottom-left
      { x: faceRight - faceW * margin, y: faceBottom - faceH * margin },  // bottom-right
      { x: faceCenterX, y: faceTop + faceH * 0.1 },                       // top-center
      { x: faceCenterX, y: faceBottom - faceH * 0.1 }                     // bottom-center (chin)
    ];
    
    const allPointsInOval = checkPoints.every(p => pointInOval(p.x, p.y, oval));
    
    // Calculate how off-center the face is
    const offsetX = Math.abs(faceCenterX - oval.cx) / oval.rx;
    const offsetY = Math.abs(faceCenterY - oval.cy) / oval.ry;
    faceOffCenter = offsetX > 0.3 || offsetY > 0.3;
    
    // Face is properly in oval if:
    // - Center is in oval
    // - All check points are in oval
    // - Not too small or too big
    // - Not too off-center
    faceInOval = centerInOval && allPointsInOval && !faceTooSmall && !faceTooBig && !faceOffCenter;
    
    faceBox = {
      x: minX * vw,
      y: minY * vh,
      w: (maxX - minX) * vw,
      h: (maxY - minY) * vh
    };
    
    // Debug logging
    // console.log(`Face: center=${centerInOval}, points=${allPointsInOval}, small=${faceTooSmall}, big=${faceTooBig}, offset=${faceOffCenter}`);
  }
  
  // Update stability - only count frames where face is properly positioned
  if (faceInOval) {
    state.stableFrames = Math.min(state.stableFrames + 1, 1000);
  } else {
    state.stableFrames = Math.max(state.stableFrames - 3, 0); // Faster reset when position is wrong
  }
  
  const isStable = state.stableFrames >= CONFIG.STABLE_FRAMES_REQUIRED;
  const eyesOpen = checkEyesOpen(result?.faceBlendshapes);
  
  // Draw oval - green only when face is properly positioned AND stable
  drawOval(faceInOval && isStable && eyesOpen);
  
  // Update UI based on phase
  if (state.phase === "scanning") {
    if (!faces?.length) {
      setStatus("No face", "warn");
      setHint("Position your face", "Move into the oval");
    } else if (faceTooSmall) {
      setStatus("Move closer", "warn");
      setHint("Too far away", "Move closer to the camera");
    } else if (faceTooBig) {
      setStatus("Move back", "warn");
      setHint("Too close", "Move back from the camera");
    } else if (faceOffCenter) {
      setStatus("Center face", "warn");
      setHint("Off center", "Move your face to the center");
    } else if (!faceInOval) {
      setStatus("Adjust position", "warn");
      setHint("Fit in oval", "Adjust your face position");
    } else if (!eyesOpen) {
      setStatus("Open eyes", "warn");
      setHint("Keep eyes open", "Look at the camera");
    } else if (!isStable) {
      setStatus("Hold still", "warn");
      setHint("Almost ready", "Keep steady for a moment");
    } else {
      setStatus("Ready", "ok");
      setHint("Perfect!", "Tap Start to capture");
      setButton("Start", true);
    }
  } else if (state.phase === "capturing") {
    const elapsed = now - state.captureStartMs;
    
    // Timeout check
    if (elapsed > CONFIG.CAPTURE_WINDOW_MS && state.captured.length < CONFIG.TARGET_FRAMES) {
      state.phase = "scanning";
      state.captured = [];
      updateProgress();
      setStatus("Too slow", "bad");
      setHint("Try again", "Keep your face steady in the oval");
      setButton("Start", true);
      requestAnimationFrame(loop);
      return;
    }
    
    // Only capture when face is properly positioned
    const canCapture = faceInOval && eyesOpen && isStable;
    const spacing = now - state.lastCaptureMs;
    
    if (canCapture && faceBox && spacing >= CONFIG.MIN_SPACING_MS) {
      const pad = faceBox.w * 0.15;
      const cropBox = {
        x: Math.max(0, faceBox.x - pad),
        y: Math.max(0, faceBox.y - pad),
        w: Math.min(vw, faceBox.w + pad * 2),
        h: Math.min(vh, faceBox.h + pad * 2)
      };
      
      if (checkQuality(cropBox.x, cropBox.y, cropBox.w, cropBox.h)) {
        const image = captureFrame(cropBox);
        state.captured.push({
          frame_id: state.captured.length,
          timestamp: Date.now(),
          image,
          hash: `${state.captured.length}-${state.nonce}-${Date.now()}`
        });
        state.lastCaptureMs = now;
        updateProgress();
        
        // Check if done
        if (state.captured.length >= CONFIG.TARGET_FRAMES) {
          verify();
          return;
        }
      }
    }
    
    // Show appropriate message during capture
    if (!canCapture) {
      setStatus("Reposition", "warn");
      setHint("Face moved", "Keep your face in the oval");
    } else {
      setStatus(`Capturing ${state.captured.length}/${CONFIG.TARGET_FRAMES}`, "ok");
      setHint("Hold still", "Capturing frames...");
    }
  }
  
  requestAnimationFrame(loop);
}

/***********************************************************************
 * VERIFICATION
 ***********************************************************************/
async function verify() {
  state.phase = "verifying";
  setLoading(true, "Verifying...");
  setStatus("Verifying", "warn");
  
  const result = await apiVerify(state.captured);
  
  setLoading(false);
  state.phase = "done";
  
  if (result?.decision === "PASS") {
    const best = state.captured[result.best_frame_id] || state.captured[state.captured.length - 1];
    showResult(true, best.image, `Confidence: ${Math.round(result.confidence * 100)}%`);
  } else {
    showResult(false, state.captured[0]?.image, "Verification failed");
  }
}

/***********************************************************************
 * ACTIONS
 ***********************************************************************/
async function handleMainButton() {
  setError("");
  
  if (state.phase === "init" || state.phase === "ready") {
    // Enable camera
    setButton("Starting...", false);
    setStatus("Loading...", "warn");
    
    // Load MediaPipe first
    if (!state.faceLandmarker) {
      setHint("Loading face detection...", "Please wait");
      const ok = await loadMediaPipe();
      if (!ok) {
        setButton("Retry", true);
        setStatus("Error", "bad");
        return;
      }
    }
    
    // Start camera
    setHint("Starting camera...", "Allow camera access if prompted");
    const camOk = await startCamera();
    if (!camOk) {
      setButton("Enable Camera", true);
      setStatus("Camera error", "bad");
      return;
    }
    
    // Start session (mock mode always succeeds)
    setHint("Initializing...", "Almost ready");
    const sessionOk = await apiStartSession();
    if (!sessionOk) {
      setError("Could not start session. Check your connection.");
      setButton("Retry", true);
      setStatus("Session error", "bad");
      return;
    }
    
    // Success - start scanning
    state.phase = "scanning";
    state.stableFrames = 0;
    setButton("Start", false);
    setStatus("Scanning", "warn");
    setHint("Position your face", "Fit inside the oval");
    loop();
    
  } else if (state.phase === "scanning") {
    // Start capture
    state.phase = "capturing";
    state.captured = [];
    state.captureStartMs = performance.now();
    state.lastCaptureMs = 0;
    updateProgress();
    setButton("Capturing...", false);
  }
}

function handleRetry() {
  stopCamera();
  hideResult();
  
  state.phase = "init";
  state.stableFrames = 0;
  state.captured = [];
  
  setStatus("Ready", "");
  setHint("Enable camera to start", "Position your face in the oval");
  setButton("Enable Camera", true);
  setError("");
  updateProgress();
  
  resizeCanvas();
  drawOval(false);
}

/***********************************************************************
 * INIT
 ***********************************************************************/
$("btnMain").addEventListener("click", handleMainButton);
$("btnRetry").addEventListener("click", handleRetry);
window.addEventListener("resize", resizeCanvas);

// Initial draw
resizeCanvas();
drawOval(false);
setButton("Enable Camera", true);
</script>
</body>
</html>
