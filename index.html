<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Identity Verification</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm/vision_bundle.mjs" type="module"></script>
    <style>
        :root {
            --bg: #09090b; --surface: #18181b; --border: #3f3f46;
            --text: #fafafa; --text-muted: #a1a1aa;
            --success: #22c55e; --warning: #f59e0b; --error: #ef4444; --primary: #3b82f6;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; display: flex; justify-content: center; padding: 20px; }
        .app { width: 100%; max-width: 440px; }
        .camera-container { position: relative; width: 100%; aspect-ratio: 3/4; background: #000; border-radius: 24px; overflow: hidden; margin-bottom: 16px; border: 1px solid var(--border); }
        #video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        .face-oval { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 65%; height: 70%; border: 3px solid rgba(255,255,255,0.2); border-radius: 50%; transition: all 0.3s; }
        .face-oval.valid { border-color: var(--success); box-shadow: 0 0 0 8px rgba(34,197,94,0.2); }
        .face-oval.detecting { border-color: var(--warning); }
        .status-bar { position: absolute; bottom: 0; left: 0; right: 0; padding: 20px; background: linear-gradient(transparent, rgba(0,0,0,0.8)); text-align: center; }
        .btn { width: 100%; padding: 16px; border: none; border-radius: 12px; font-size: 16px; font-weight: 600; cursor: pointer; background: var(--primary); color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .quality-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 16px; }
        .q-item { background: var(--surface); padding: 8px; border-radius: 8px; font-size: 10px; text-align: center; color: var(--text-muted); border: 1px solid var(--border); }
        .q-item.pass { border-color: var(--success); color: var(--success); }
        .progress-bar { position: absolute; top: 0; left: 0; height: 4px; background: var(--success); width: 0%; transition: width 0.3s; }
        #debug { position: absolute; top: 10px; right: 10px; font-size: 10px; color: yellow; pointer-events: none; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="app">
        <div id="mainFlow">
            <div class="camera-container">
                <video id="video" autoplay playsinline muted></video>
                <div class="progress-bar" id="progress"></div>
                <div class="face-oval" id="oval"></div>
                <div id="debug"></div>
                <div class="status-bar">
                    <h2 id="statusTitle">Ready</h2>
                    <p id="statusSubtitle" style="font-size: 12px; color: var(--text-muted)">Align your face to begin</p>
                </div>
            </div>
            <button class="btn" id="startBtn">Start Verification</button>
            <div class="quality-grid">
                <div class="q-item" id="q-face">Face</div>
                <div class="q-item" id="q-pose">Pose</div>
                <div class="q-item" id="q-eyes">Eyes</div>
                <div class="q-item" id="q-still">Still</div>
            </div>
        </div>

        <div id="resultScreen" class="hidden" style="text-align: center; padding-top: 50px;">
            <h1 id="resTitle">Result</h1>
            <p id="resMsg"></p>
            <button class="btn" onclick="location.reload()" style="margin-top: 20px;">Try Again</button>
        </div>
    </div>

    <canvas id="tempCanvas" class="hidden"></canvas>
    <canvas id="cropCanvas" width="224" height="224" class="hidden"></canvas>

    <script type="module">
        import { FaceDetector, FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/+esm';

        const CONFIG = {
            API_URL: 'http://localhost:5000',
            FACE_CONFIDENCE: 0.85,
            MAX_YAW: 22, MAX_PITCH: 20, MAX_ROLL: 15,
            MIN_EAR: 0.18, 
            STABILITY_THRESHOLD: 0.012,
            STABILITY_REQUIRED_FRAMES: 5,
            TOTAL_FRAMES: 5,
            MIN_FRAME_SPACING: 450
        };

        const state = {
            isRunning: false, detector: null, landmarker: null, stream: null,
            captured: [], lastCapture: 0, stability: 0, history: [], session: null
        };

        async function init() {
            const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm');
            state.detector = await FaceDetector.createFromOptions(vision, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite`, delegate: 'GPU' }, runningMode: 'VIDEO' });
            state.landmarker = await FaceLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`, delegate: 'GPU' }, runningMode: 'VIDEO', outputFaceBlendshapes: true });
            document.getElementById('statusTitle').innerText = 'System Ready';
        }

        async function start() {
            state.stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 }, audio: false });
            document.getElementById('video').srcObject = state.stream;
            
            const resp = await fetch(`${CONFIG.API_URL}/session/start`, { method: 'POST' }).catch(() => ({ json: () => ({ session_id: 'demo', nonce: 'demo' }) }));
            state.session = await resp.json();
            
            state.isRunning = true;
            state.captured = [];
            loop();
        }

        function loop() {
            if (!state.isRunning) return;
            requestAnimationFrame(loop);

            const video = document.getElementById('video');
            if (video.readyState < 2) return;

            const canvas = document.getElementById('tempCanvas');
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            const ts = performance.now();
            const det = state.detector.detectForVideo(video, ts).detections[0];
            const land = state.landmarker.detectForVideo(video, ts);

            if (!det || !land.faceLandmarks[0]) {
                updateUI(null, false);
                return;
            }

            const results = checkGates(det, land);
            const isStill = checkStill(land.faceLandmarks[0]);
            
            updateUI(results, isStill);

            if (results.all && isStill) {
                state.stability++;
                if (state.stability > CONFIG.STABILITY_REQUIRED_FRAMES && (Date.now() - state.lastCapture > CONFIG.MIN_FRAME_SPACING)) {
                    capture(det.boundingBox, canvas);
                }
            } else {
                state.stability = 0;
            }
        }

        function checkGates(det, land) {
            const box = det.boundingBox;
            const landmarks = land.faceLandmarks[0];
            const shapes = land.faceBlendshapes[0]?.categories || [];

            // 1. Pose estimation (Simplified)
            const yaw = (landmarks[4].x - (landmarks[33].x + landmarks[263].x) / 2) * 100;
            const pitch = (landmarks[4].y - (landmarks[33].y + landmarks[263].y) / 2) * 100;

            // 2. Eye check using MediaPipe Blendshapes (Robust on mobile)
            const lb = shapes.find(s => s.categoryName === 'eyeBlinkLeft')?.score || 0;
            const rb = shapes.find(s => s.categoryName === 'eyeBlinkRight')?.score || 0;
            const eyesOpen = lb < 0.4 && rb < 0.4;

            const gates = {
                face: det.categories[0].score > CONFIG.FACE_CONFIDENCE,
                pose: Math.abs(yaw) < CONFIG.MAX_YAW && Math.abs(pitch) < CONFIG.MAX_PITCH,
                eyes: eyesOpen
            };

            return { ...gates, all: Object.values(gates).every(v => v), yaw, pitch };
        }

        function checkStill(points) {
            const curr = points.slice(0, 10);
            if (state.history.length === 0) { state.history.push(curr); return false; }
            const prev = state.history[state.history.length - 1];
            state.history.push(curr); if (state.history.length > 5) state.history.shift();
            
            let d = 0;
            for (let i = 0; i < 10; i++) d += Math.hypot(curr[i].x - prev[i].x, curr[i].y - prev[i].y);
            return (d / 10) < CONFIG.STABILITY_THRESHOLD;
        }

        function capture(bbox, srcCanvas) {
            const crop = document.getElementById('cropCanvas');
            const ctx = crop.getContext('2d');
            const pad = bbox.width * 0.2;
            ctx.drawImage(srcCanvas, bbox.originX - pad, bbox.originY - pad, bbox.width + pad*2, bbox.height + pad*2, 0, 0, 224, 224);
            
            state.captured.push({
                image: crop.toDataURL('image/jpeg', 0.7),
                frame_id: state.captured.length,
                timestamp: Date.now()
            });
            state.lastCapture = Date.now();
            document.getElementById('progress').style.width = `${(state.captured.length / CONFIG.TOTAL_FRAMES) * 100}%`;

            if (state.captured.length >= CONFIG.TOTAL_FRAMES) upload();
        }

        async function upload() {
            state.isRunning = false;
            document.getElementById('statusTitle').innerText = 'Verifying...';
            try {
                const res = await fetch(`${CONFIG.API_URL}/verify`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: state.session.session_id,
                        nonce: state.session.nonce,
                        frames: state.captured,
                        client_metadata: { user_agent: navigator.userAgent }
                    })
                });
                const data = await res.json();
                showResult(data);
            } catch (e) {
                showResult({ decision: 'ERROR', message: 'Network failed' });
            }
        }

        function updateUI(res, still) {
            const oval = document.getElementById('oval');
            if (!res) {
                oval.className = 'face-oval';
                document.getElementById('statusTitle').innerText = 'No Face';
                return;
            }
            
            document.getElementById('q-face').className = `q-item ${res.face ? 'pass' : ''}`;
            document.getElementById('q-pose').className = `q-item ${res.pose ? 'pass' : ''}`;
            document.getElementById('q-eyes').className = `q-item ${res.eyes ? 'pass' : ''}`;
            document.getElementById('q-still').className = `q-item ${still ? 'pass' : ''}`;

            oval.className = `face-oval ${res.all && still ? 'valid' : 'detecting'}`;
            document.getElementById('statusTitle').innerText = res.all && still ? 'Hold Still...' : 'Adjust Position';
            document.getElementById('debug').innerText = `Y: ${res.yaw?.toFixed(1)} P: ${res.pitch?.toFixed(1)}`;
        }

        function showResult(data) {
            document.getElementById('mainFlow').className = 'hidden';
            const screen = document.getElementById('resultScreen');
            screen.className = '';
            document.getElementById('resTitle').innerText = data.decision === 'PASS' ? 'Success!' : 'Failed';
            document.getElementById('resMsg').innerText = data.message;
            if (state.stream) state.stream.getTracks().forEach(t => t.stop());
        }

        document.getElementById('startBtn').onclick = start;
        init();
    </script>
</body>
</html>